"""
PYTHON script for importing arbitrary profiles onto DF-ISE simulation
grids for use with Sentaurus TCAD.

Gavin Forcade, 2022

This script reads a DF-ISE .dat file to determine the spatial coordinates of
of each grid point. It then generates a new .dat file containing an
OpticalGeneration profile that was calculated by FDTD. The key input/output
settings and the mapping function are indicated by comments in the code.

"""






def isfloat(num):
	try:
		float(num)
		return True
	except ValueError:
		return False


class regionArray:
	def __init__(self):
		self.x		= 0
		self.y		= 0
		self.z		= 0

"""
%DAT file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
B.10. SELECTED SOURCE CODE 27
%This should be a valid DF-ISE .dat file (i.e. generated by mesh or
%noffset3d. The meshing program must be scripted to store the x- and y-
%position of each vertex of the grid as "PMIUserField0" and
%"PMIUserField1", respectively.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
"""

def stitchMesh(inFileName,opticalGenFileName,outFileName):
	
	
	#initial time for the run
	t0 = time.time()

	datFile = inFileName+'.dat'
	grdFile = inFileName+'.grd'



	#optical generation file
	opticalGenFile = opticalGenFileName+' '


	outputFile = outFileName+'.dat'
	outputGrid = outFileName+'.grd'


	#Number of data values to output per line in output DAT file
	numperline = 10



	print('--------------------------------------------------------')
	print('OptGenConverter Version 1')
	print('Gavin Forcade, 2022')
	print('University of Ottawa, SUNLAB')
	print("Running Python")
	print('--------------------------------------------------------')
	print('\n\n\n')





	print('Reading data points...')

	regionCell = {}
	headers = []
	with open(datFile) as grd:
		# Main reading loop. Look for PMIUserField 0,1,2 data sets...
		while True:
			line = grd.readline()
			if 'datasets' in line:
				break
			headers.append(line)
		while True:
			if not line:
				break
			line = grd.readline()
			if 'function  = PMIUserField' in line:
				axisNumber = float(line[-2])
				while 'validity  =' not in line:
					line = grd.readline()
				regionName = re.findall('\"(\w+)\"',line)[0]
				line = grd.readline()
				line = grd.readline()
				dataPoints = np.array([])
				while True:
					data = line.split()
					if not isfloat(data[0]):
						break
					dataPoints = np.append(dataPoints,np.float_(data))
					line = grd.readline()

				if regionName not in regionCell:
					regionCell[regionName] = regionArray()

				if axisNumber == 0:
					regionCell[regionName].x = dataPoints
				elif axisNumber == 1:
					regionCell[regionName].y = dataPoints
				elif axisNumber == 3:
					regionCell[regionName].z = dataPoints


	print('Completed reading DAT file')
	print(' Read ' + str(len(regionCell)) + ' region(s) \n')



	"""
	Will now load optical generation results.
	"""

	print('Loading optical generation from' + opticalGenFile + '\n')

	#optGenData = loadData()
	#interp_spline = interpolate.RectBivariateSpline(optGenData_x,y,z)

	#use functions to load opticalGenFile to have correct format
	def optGen(x,y,z,regionName):
		if 'em' in regionName:
			return 1.0
			#return interp_spline(x,y,z)
		else:
			return 0.0



	#creating output file
	with open(outputFile,"w") as fid:
		fid.write(''.join(headers))
		fid.write("  datasets    = [ ")
		for i in range(len(regionCell)):
			fid.write(' "OpticalGeneration" ')
		fid.write(']\n  functions   = [')
		for i in range(len(regionCell)):
			fid.write(' OpticalGeneration ')
		fid.write(']\n}\n\nData {\n\n') 
		for regionName in regionCell.keys():
			print('Writing data for ' + regionName + ' to the output file.')
			fid.write('  Dataset ("OpticalGeneration") {\n    function  = OpticalGeneration\n    type      = scalar\n    dimension = 1\n' \
			'    location  = vertex\n    validity  = [ "' + regionName + '" ]\n    Values (' + str(len(regionCell[regionName].x)) + ') {\n')
			for nOG in range(len(regionCell[regionName].x)):
				fid.write(' ' +str(optGen(regionCell[regionName].x,regionCell[regionName].y,regionCell[regionName].z,regionName)))
				if (nOG+1)%numperline == 0:
					fid.write('\n')
			if len(regionCell[regionName].x)%numperline != 0:
				fid.write('\n')
			fid.write('    }\n  }\n\n')
		fid.write('\n\n}')

	print('\n\nFinished writing output file ' + outputFile)

				
	print("\nDone.")

	print('\n\nMesh stitching time: ' + "{:.4}".format(time.time() - t0) + ' s')




if __name__=='__main__':
	import re
	import sys
	import time
	import numpy as np
	from scipy import interpolate
	stitchMesh(*sys.argv[1:])






